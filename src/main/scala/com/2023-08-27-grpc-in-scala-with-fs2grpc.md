---
title: "Grpc in scala with Fs2Grpc"
date: 2023-07-27
header:
  image: "/images/blog cover.jpg"
tags: []
excerpt: "Understand the workings of grpc in scala."
toc: true
toc_label: "In this article"
---

## 1. Introduction

RPC stands for Remote Procedure Call, it is a client-server communication protocol where on program can request a service on a different address which may be on the same system or a different system connected by a network. It enables users work with remote procedures as if they were local.
In this article we will cover gRPC which is a modern Open Source RPC frameworkdesigned by Google that uses protocal buffers for data serialization and HTTP/2 as a transport layer. gRPC is language independent therefore it's possible for a client written in one language to communication with a server written in another. At the time of wrtitng this article, gRPC officially supports a 11 programming languages including python, java, kotlin and c++ to mention a few.
Scala is not officially supported at the moment however the scalaPB library provides a good wrapper around the official gRPC Java implementation and it provides an easy API that enables translation of Protocol Buffers to Scala case classes with support for Scala3, Scala.js and Java Interoperability.
One of the main use cases for gRPC is communication between internal microservices, in this tutorial, we'll simulate communication with an order service using gRPC to process streams of orders from an ecommerce platform.

## 2. Setting Up.

Create a new scala project, in your project folder, create a plugins.sbt file witht he following code.

```scala
addSbtPlugin("org.typelevel" % "sbt-fs2-grpc" % "2.7.4")
```

Also add the following code to your `build.sbt` file.

```scala
val scala3Version = "3.3.0"
val http4sVersion = "0.23.23"
val circeVersion = "0.14.5"
val squantsVersion = "1.8.3"

lazy val protobuf =
  project
    .in(file("protobuf"))
    .settings(
      name:= "protobuf",
      scalaVersion := scala3Version
    )
    .enablePlugins(Fs2Grpc)

lazy val root =
  project
    .in(file("."))
    .settings(
      name:= "root",
      scalaVersion := scala3Version,
      libraryDependencies += "io.grpc" % "grpc-netty-shaded" % scalapb.compiler.Version.grpcJavaVersion,
      libraryDependencies ++= Seq(
        "org.http4s" %% "http4s-ember-client" % http4sVersion,
        "org.http4s" %% "http4s-ember-server" % http4sVersion,
        "org.http4s" %% "http4s-dsl"          % http4sVersion,
      ),
      libraryDependencies ++= Seq(
        "org.http4s" %% "http4s-circe" % http4sVersion,
        "io.circe" %% "circe-generic" % circeVersion,
        "io.circe" %% "circe-literal" % circeVersion,
      )
    )
    .dependsOn(protobuf)
```

Here we have a root `project` which depends on `protobuf`, with this design, when `root` is compiled, the `Fs2Grpc` plugin automatically generates case classes from our `.proto` file. It depends on `scalapb` for to generate case classes.

We'll use circe for JSON encoding and decoding, and `http4s` to develope our REST server from which we forwards orders to the order service using grpc.

## 3. The .proto file

Create a folder called `protobuf` in the root of your project and add an `orders.proto` file in the following path, `protobuf/src/main/protobuf/orders.proto`.

Now add the following to the file.

```proto
syntax = "proto3";

package com.xonal.protos;
```

A .proto file contains Google's protocol buffer language, it's used to structure protocol buffer data. scalaPB supports both proto2 and proto3 versions.
In the first line of the file we define the `syntax` which is the protobuf language version. Next we specify package as `com.xonal.protos`, this will be the namespace through which we access the case classes generated by `fs2-grpc`.

```proto
...
// The order service definition.
service Order {
  rpc SendOrderStream (stream OrderRequest) returns (stream OrderReply) {}
}
```

Here we define our `Order` service which contains a single function, `SendOrderStream()` that takes a stream of `OrderRequest`s and returns a stream of `OrderReply`s. The OrderService will be translated to a scala `Trait` through which we can access our function.

```proto
...
message Item{
  string name = 1;
  int32 qty = 2;
  double amount = 3;
}
```

A `message` is a data structure containing a set of typed fields. We define `Item` which contains three fields name, qty and amount of type `string`, `int32` and `double`. The "= 1", "= 2" and "= 3" are unique tags used by each field in binary encoding.
`messages` get translated to case classes during compilation.

```proto
...
message OrderRequest {
  int32 orderid = 1;
  repeated Item items = 2;
}

message OrderReply {
  int32 orderid = 1;
  repeated Item items = 2;
  double total = 3;
}
```

Above we define two more messages, `OrderRequest`, and `OrderReply`. `OrderRequest` consists of an `orderid` of type `int32` and items of type `Item`, this shows that we can nest a message within a message. The `repeated` annotation means that items can be repeated any number of times, in scala this becomes a `Seq` of `Item`.
`OrderReply` also consists of an `orderid` of type `int32`, `items` which is a `repeated` `Item` and `total` of type `double`.

Here's the full code:

```proto
syntax = "proto3";

package com.xonal.protos;

service Order {
  rpc SendOrderStream (stream OrderRequest) returns (stream OrderReply) {}
}

message Item{
  string name =1;
  int32 qty = 2;
  double amount = 3;
}

message OrderRequest {
  int32 orderid = 1;
  repeated Item items = 2;
}

message OrderReply {
  int32 orderid = 1;
  repeated Item items = 2;
  double total = 3;
}
```

When we compile our project, and check `protobuf/target/scala-3.3.0/src_managed/main`, we'll find to sets of generated files, one under the fs2-grpc folder that contains our `trait` while the rest are cases classes under the scalapb folder. If we look at the top of each of these files, we'll find that they are all under the `com.xonal.protos.orders` package namespace that we defined in our `orders.proto` file.

## 4. The gRPC server.
If we take a look at the `OrderFs2Grpc.scala` file generated by `fs2-grpc`:

```scala
trait OrderFs2Grpc[F[_], A] {
  def sendOrderStream(request: _root_.fs2.Stream[F, com.xonal.protos.orders.OrderRequest], ctx: A): _root_.fs2.Stream[F, com.xonal.protos.orders.OrderReply]
}
```
We'll notice that a `OrderFs2Grpc` was created with a single function `sendOrderStream()` similar to what we defined in orders.proto. Lets provide an implementation for the above function.

Create OrderService.scala in the following path `src/main/scala/com/xonal/service/OrderService.scala` and add the following code.

```scala
package com.xonal.service

import com.xonal.protos.orders.*
import cats.effect.*
import _root_.io.grpc.*
import fs2.Stream

private class OrderService extends OrderFs2Grpc[IO, Metadata] {
  override def sendOrderStream(
      request: Stream[IO, OrderRequest],
      ctx: Metadata
  ): Stream[IO, OrderReply] = {
    request.map { orderReq =>
      OrderReply(
        orderReq.orderid,
        orderReq.items,
        orderReq.items.map(i => i.amount).reduce(_ + _)
      )
    }
  }
}
```
Here we create a new class `OrderService` that extends our `OrderFs2Grpc` trait, it requires an effect type and context to which we provide `IO` from `cats.effect` and `Metadata` from `io.grpc`. `Metadata` provides access to read and write metadata values to be exchanged during a call. 

Looking at the implementation of `sendOrderStream` above, for each `OrderRequest` in a `Stream`, we produce an `OrderReply` with the same `orderid`, a `Seq` of `Item`s and the `total` amount which we calculate using the `reduce(_+_)` function.

```scala
import _root_.io.grpc.netty.shaded.io.grpc.netty.NettyServerBuilder
import fs2.grpc.syntax.all.*

...

object Server {
  private val orderService: Resource[IO, ServerServiceDefinition] =
    OrderFs2Grpc.bindServiceResource[IO](new OrderService)

  private def runServer(service: ServerServiceDefinition) = NettyServerBuilder
    .forPort(9999)
    .addService(service)
    .resource[IO]
    .evalMap(server => IO(server.start()))
    .useForever

  val grpcServer = orderService.use(srvr => runServer(srvr))
}
```
Here we create a `Resource[IO, ServerServiceDefinition]` by calling the `bindServiceResource()` method on `OrderFs2Grpc` and passing it a service implementation, in our case a new instance of `OrderService`.

The runServer function uses `NettyServerBuilder` to create our server with port number `9999`. On the last line we call the `use()` method on our `orderService` `Resource` and pass the `ServerServiceDefinition` to `runServer()`.

Here's the full code:
```scala
package com.xonal.service

import com.xonal.protos.orders.*
import cats.effect.*
import _root_.io.grpc.*
import fs2.Stream
import _root_.io.grpc.netty.shaded.io.grpc.netty.NettyServerBuilder
import fs2.grpc.syntax.all.*

private class OrderService extends OrderFs2Grpc[IO, Metadata] {
  override def sendOrderStream(
      request: Stream[IO, OrderRequest],
      ctx: Metadata
  ): Stream[IO, OrderReply] = {
    request.map { orderReq =>
      OrderReply(
        orderReq.orderid,
        orderReq.items.map(i => i.name),
        orderReq.items.map(i => i.amount).reduce(_ + _)
      )
    }
  }
}

object Server {
  private val orderService: Resource[IO, ServerServiceDefinition] =
    OrderFs2Grpc.bindServiceResource[IO](new OrderService)

  private def runServer(service: ServerServiceDefinition) = NettyServerBuilder
    .forPort(9999)
    .addService(service)
    .resource[IO]
    .evalMap(server => IO(server.start()))
    .useForever

  val grpcServer = orderService.use(srvr => runServer(srvr))
}
```
## 4. The gRPC client.
Create `OrderClient.scala` in the folloing path, `src/main/scala/com/xonal/client/OrderClient.scala` and add the following code.

```scala
package com.xonal.client

import cats.effect.*
import _root_.io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder
import _root_.io.grpc.*
import fs2.grpc.syntax.all.*

object Client {
  val managedChannelResource: Resource[IO, ManagedChannel] =
    NettyChannelBuilder
      .forAddress("127.0.0.1", 9999)
      .usePlaintext()
      .resource[IO]
}
```
Here we create a `Client` object with its first element, `managedChannelResource`. We use `NettyChannelBuilder` to construct a channel that uses Netty transport. A channel provides a connection to a network socket or component which is capable of I/O operations such as read, write, connect and bind. 
The `forAddress()` method adds host and port (same as our server) values. The `usePlaintext()` method sets the negotiation type for the Http/2 connection to `PLAINTEXT` since `ManagedChannel`'s use `TLS` by default and finally the `resource()` method builds the `ManagedChannel` into a `Resource`.

```scala
...
import com.xonal.protos.orders.*
import fs2.Stream

object Client {
  ...
  def formatItemsToStr(items: Seq[Item]): Seq[String] = {
    items.map(x => s"[${x.qty} of ${x.name}]")
  }

  def processorFn(orders: Stream[IO, OrderRequest]) = {
    def processor(orderStub: OrderFs2Grpc[IO, Metadata]): IO[List[String]] = {
      for {
        response <- orderStub.sendOrderStream(orders, new Metadata())
        str <- Stream.eval(
          IO(s"Processed orderid: ${response.orderid} for items ${response.names
              .mkString(",")} totaling to USD ${response.total}")
        )
      } yield str
    }.compile.toList
  }
}
```
Within `processorFn()` is a nested function, `processor()` that takes an `orderStub` of type `OrderFs2Grpc[IO, Metadata]` and calls `sendOrderStream(orders, new Metadata())`, this returns a `Stream[IO, OrderReply]` on which we `flatMap` to format each `OrderReply` into a `String` that informs the user of their `orderid`, the `items` they bought and the `total` they spent for each order, this `Stream` is compiled to return an `IO[List[String]]`. We use the `formatItemsToStr()` function to format the `Seq[Item]` in the `OrderReply`.

```scala
...
def processorFn(orders: Stream[IO, OrderRequest]): IO[List[String]] = {
  ...
  def runClient: IO[List[String]] =
      managedChannelResource
        .flatMap(ch => OrderFs2Grpc.stubResource[IO](ch))
        .use(processor)

  runClient
}
```
Still within the `processorFn()` function, we `flatMap` our `managedChannelResource` and pass the `ManagedChannel` to `OrderFs2Grpc.stubResource[IO]()` to create a `Resource[IO, OrderFs2Grpc[IO, Metadata]]` which we finally `use` in the last line to pass our orders to the server. The `processorFn()` function returns a call to `runClient` which results in an IO[List[String]].

Here's the full code:

```scala
package com.xonal.client

import cats.effect.*
import _root_.io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder
import _root_.io.grpc.*
import fs2.grpc.syntax.all.*
import com.xonal.protos.orders.*
import fs2.Stream

object Client {
  val managedChannelResource: Resource[IO, ManagedChannel] =
    NettyChannelBuilder
      .forAddress("127.0.0.1", 9999)
      .usePlaintext()
      .resource[IO]

  def formatItemsToStr(items: Seq[Item]): Seq[String] = {
    items.map(x => s"[${x.qty} of ${x.name}]")
  }

  def processorFn(orders: Stream[IO, OrderRequest]): IO[List[String]] = {
    def processor(orderStub: OrderFs2Grpc[IO, Metadata]): IO[List[String]] = {
      for {
        response <- orderStub.sendOrderStream(orders, new Metadata())
        str <- Stream.eval(
          IO(
            s"Processed orderid: ${response.orderid} for items: ${formatItemsToStr(response.items)
                .mkString(" and ")}, totaling to USD ${response.total}"
          )
        )
      } yield str
    }.compile.toList

    def runClient: IO[List[String]] =
      managedChannelResource
        .flatMap(ch => OrderFs2Grpc.stubResource[IO](ch))
        .use(processor)

    runClient
  }
}

```

## 5. The Routes
In this section we define the logic to hanlde incoming requests to our REST server. Create AppRoutes.scala in the following path src/main/scala/com/xonal/routes/AppRoutes.scala., and add the code below:

```scala
package com.xonal.routes

import cats.effect.IO
import org.http4s.*
import org.http4s.dsl.io.*

object MyRoutes {
  def restService = HttpRoutes.of[IO] {
    case req @ GET -> Root / "index.html" =>
      StaticFile
        .fromString[IO](
          "src/main/scala/index.html",
          Some(req)
        )
        .getOrElseF(NotFound())
  }
}
```
Above we define our first route `/index.html` that serves the client with an html page where one can make orders from our E-Commerce store. It uses the `fromString()` method from `Http4s`'s `StaticFile` object which takes a `url` to an html file and an `Option` of a `Request[IO]`. If the url is incorrect the client recieves status code `404`, meaning the page is not available.

```scala
...
import com.xonal.protos.orders.OrderRequest

object MyRoutes {
  case class Orders(values: Seq[OrderRequest])

  def restService = HttpRoutes.of[IO] {
    ...
    case req @ POST -> Root / "submit" => ???
  }
}
```
Here we create our second route `/submit` which will recieve `POST` requests with a user's orders. We create an Orders case class to capture the `Seq` or `OrderRequest`'s that the user sends. However inorder to parse our request, we'll need an `EntityDecoder` for `Orders` in scope. We'll also need `Decoder`s for `Orders`, `OrderRequest` and `Item` in scope.

```scala
import com.xonal.protos.orders.{OrderRequest, Item}
import org.http4s.circe.*
import io.circe.Decoder
import io.circe.syntax.*
import scala.util.Random
import scala.math.BigDecimal

object MyRoutes {
  case class Orders(values: Seq[OrderRequest])
  given ordersEntityDecoder: EntityDecoder[IO, Orders] = jsonOf[IO, Orders]

  given ordersDecoder: Decoder[Orders] = Decoder.instance { h =>
    h.get[Seq[OrderRequest]]("orders").map { orders =>
      Orders(orders)
    }
  }

  given itemDecoder: Decoder[Item] = Decoder.instance { h =>
    for
      name <- h.get[String]("name")
      qty <- h.get[Int]("quantity")
      amount <- h.get[BigDecimal]("amount")
    yield Item.of(
      name,
      qty,
      amount
    )
  }

  given orDecoder: Decoder[OrderRequest] = Decoder.instance { h =>
    h.get[Seq[Item]]("items").map { items =>
      OrderRequest.of(Random.between(1000, 2000), items)
    }
  }
  ...
}
```
Here we added an `EntityDecoder` for `Orders` using the `jsonOf[IO, Orders]` function provided by `http4s.circe`. For this EntityDecoder to work, we also need to provide a given of type Decoder[Orders] which we do witht he help of circe's Decoder.instance function. We would target the `orders` key from the incoming json string and pass its value to the `Orders` case class. 

A similar process is done for the `Item` and `OrderRequest` `Decoder`s. For the `OrderRequest` `Decoder`, we use a `Random` `Int` between 1000 and 2000 to simulate the `orderid`. 
`ScalaPB` provides a convinient `of()` function to pass data to our case class without having to deal with `UnknownFieldSet.empty` which if you check on the generated code is part of every case class. We can build these classes in different ways depending on your preference, here some examples with OrderRequest.

```scala
// Using the of() method
OrderRequest.of(Random.between(1000, 2000), items)

//Using withX() method
OrderRequest()
  .withOrderid(Random.between(1000,2000))
  .withItems(items)

//Default method
// Here we would have to import UnknownFieldSet
import scalapb.UnknownFieldSet
OrderRequest(
  Random.between(1000,2000),
  items,
  _root_.scalapb.UnknownFieldSet.empty
)
```

Now we can process the incoming `POST` request.

```scala
...
import com.xonal.client.Client.processorFn
import fs2.Stream

object MyRoutes {
  ...
  def restService = HttpRoutes.of[IO] {
    ...
     case req @ POST -> Root / "submit" =>
      req
        .as[Orders]
        .flatMap { x =>
          processorFn(Stream.emits(x.values).covary[IO])
        }
        .handleError(x => List(x.getMessage))
        .flatMap(x => Ok(x.asJson))
  }
}
```
Using the `as()` method on the request parses our json string returning `IO[Orders]`. We flatMap on this to pass the Orders to our `processorFn()` function which communicates with the gRPC server to process them. This returns either an IO[List[String]] in case of success or an error message which we package in a `List` in case of failure. This `List` is then passed back to the browser as a json array of string.

Here's the full code:

```scala
package com.xonal.routes

import cats.effect.IO
import org.http4s.*
import org.http4s.dsl.io.*
import com.xonal.protos.orders.{OrderRequest, Item}
import org.http4s.circe.*
import io.circe.Decoder
import io.circe.syntax.*
import scala.util.Random
import com.xonal.client.Client.processorFn
import fs2.Stream

object MyRoutes {
  case class Orders(values: Seq[OrderRequest])
  given ordersEntityDecoder: EntityDecoder[IO, Orders] = jsonOf[IO, Orders]

  given ordersDecoder: Decoder[Orders] = Decoder.instance { h =>
    h.get[Seq[OrderRequest]]("orders").map { orders =>
      Orders(orders)
    }
  }

  given itemDecoder: Decoder[Item] = Decoder.instance { h =>
    for
      name <- h.get[String]("name")
      qty <- h.get[Int]("quantity")
      amount <- h.get[Double]("amount")
    yield Item.of(
      name,
      qty,
      amount
    ) // Item().withName(name).withQty(qty).withAmount(amount)
  }

  given orDecoder: Decoder[OrderRequest] = Decoder.instance { h =>
    h.get[Seq[Item]]("items").map { items =>
      OrderRequest.of(Random.between(1000, 2000), items)

      // OrderRequest()
      //  .withOrderid(Random.between(1000,2000))
      //  .withItems(items)

      // OrderRequest(
      //   Random.between(1000,2000),
      //   items,
      //   _root_.scalapb.UnknownFieldSet.empty
      // )
    }
  }

  def restService = HttpRoutes.of[IO] {
    case req @ GET -> Root / "index.html" =>
      StaticFile
        .fromString[IO](
          "src/main/scala/index.html",
          Some(req)
        )
        .getOrElseF(NotFound())
    case req @ POST -> Root / "submit" =>
      req
        .as[Orders]
        .flatMap { x =>
          processorFn(Stream.emits(x.values).covary[IO])
        }
        .handleError(x => List(x.getMessage))
        .flatMap(x => Ok(x.asJson))
  }
}
```

## .7 Index.html
Create the index.html file in the following path, src/main/scala/index.html, this file is quite lengthy, we can copy the contents from this link.
It consists of 3 forms each with the following format:

```html
<form>
        <fieldset>
          <span style="font-weight: bold; color: darkorchid">Items</span><br />
          <span style="color: crimson">FlagShip Phones</span><br />
          <input type="radio" id="phone1" name="flagship" value="iphone" />
          <label for="phone1">Iphone 14 -> $1099.99</label><br />
          <input type="radio" id="phone2" name="flagship" value="s23" />
          <label for="phone2">Samsung Galaxy s23 Ultra -> $999.99</label><br />
          <input type="radio" id="phone3" name="flagship" value="edge" />
          <label for="phone3">Motorola Moto Edge+ -> $799.99</label><br />
          <span style="color: crimson">Quantity</span><br />
          <input type="number" name="flagshipQty" /><br />
          <br />
          <span style="color: crimson">Budget Phones</span><br />
          <input type="radio" id="phone4" name="budget" value="nord" />
          <label for="gs1">OnePlus Nord N30 -> $270.00</label><br />
          <input type="radio" id="phone5" name="budget" value="a14" />
          <label for="gs2">Samsung Galaxy A14 -> $200.00</label><br />
          <input type="radio" id="phone6" name="budget" value="motog" />
          <label for="gs3">Motorola Moto G Stylus -> $170.00</label><br />
          <span style="color: crimson">Quantity</span><br />
          <input type="number" name="budgetQty" /><br />
          <br />
        </fieldset>
      </form>
```
Each form has two sections where one can select a Flagship phone and a Budget phone ones prefered quantity.

```html
<div>
  <button id="submitBtn">Submit All</button>
</div>
<div id="reply"></div>
```
We provide a `Submit All` button that will fetch all the inputted data using JavaScript, post the data, and append the response to the `div` with id `reply`.

```js
const prices = {
  iphone: 1099.99,
  s23: 999.99,
  edge: 799.99,
  nord: 270.0,
  a14: 200.0,
  motog: 170.0,
};
const names = {
  iphone: "Iphone 14",
  s23: "Samsung Galaxy s23 Ultra",
  edge: "Motorola Moto Edge+",
  nord: "OnePlus Nord N30",
  a14: "Samsung Galaxy A14",
  motog: "Motorola Moto G Stylus",
};

const forms = document.getElementsByTagName("form");

const submitButton = document.getElementById("submitBtn");
const replyDiv = document.getElementById("reply");
```
To process the forms we first create two objects containing the phone prices and phone names. We also get all the form elements, assign them to `forms`, as well as the  submit button and div to post our response which are assigned to `submitButton` and `replyDiv` respectively.

```js
...
submitButton.addEventListener("click", (event) => {
  var orderObj = { orders: [] };
  for (let i = 0; i < forms.length; i++) {
    const formData = new FormData(forms[i]);
    const jsonObject = Object.fromEntries(formData);
    var jsonFormatted = {
      items: [
        {
          name: names[jsonObject["flagship"]],
          quantity: jsonObject["flagshipQty"],
          amount: prices[jsonObject["flagship"]],
        },
        {
          name: names[jsonObject["budget"]],
          quantity: jsonObject["budgetQty"],
          amount: prices[jsonObject["budget"]],
        },
      ],
    };
    orderObj.orders.push(jsonFormatted);
  }
}
```
Next we create an event listener for a clieck event on the submit Button. When the button is clicked we run through all the forms using a for loop and fetch the data from each by calling `new FormData(forms[i])`. 
We then reformat the data to resemble our scala case classes and assigned each form's data to `jsonFormatted`, this is then pushed to `orderObj` which is an `object` conataining an `Array` of `orders`.

```js
submitButton.addEventListener("click", (event) => {
  ...
  async function sendForm() {
    const res = await fetch("http://localhost:8080/submit", {
      method: "POST",
      body: JSON.stringify(orderObj),
    });
    const resData = await res.json();
    return resData;
  }
  return sendForm()
    .then((arr) => arr.map((str) => {
      var p = document.createElement('p')
      p.textContent = str;
      p.style.color = "darkorchid";
      replyDiv.appendChild(p);
    }))
    .catch((err) => (replyDiv.innerHTML = err));
}
```
The last section is an async function `sendForm()` that uses JavaScripts fetch API to submit our from data as JSON and append the response to the a `div`.

Heres the full javaScript code:

```js
const prices = {
  iphone: 1099.99,
  s23: 999.99,
  edge: 799.99,
  nord: 270.0,
  a14: 200.0,
  motog: 170.0,
};
const names = {
  iphone: "Iphone 14",
  s23: "Samsung Galaxy s23 Ultra",
  edge: "Motorola Moto Edge+",
  nord: "OnePlus Nord N30",
  a14: "Samsung Galaxy A14",
  motog: "Motorola Moto G Stylus",
};

const forms = document.getElementsByTagName("form");

const myButton = document.getElementById("submitBtn");
const replyDiv = document.getElementById("reply");

myButton.addEventListener("click", (event) => {
  var orderObj = { orders: [] };
  for (let i = 0; i < forms.length; i++) {
    const formData = new FormData(forms[i]);
    const jsonObject = Object.fromEntries(formData);
    var jsonFormatted = {
      items: [
        {
          name: names[jsonObject["flagship"]],
          quantity: jsonObject["flagshipQty"],
          amount: prices[jsonObject["flagship"]],
        },
        {
          name: names[jsonObject["budget"]],
          quantity: jsonObject["budgetQty"],
          amount: prices[jsonObject["budget"]],
        },
      ],
    };
    orderObj.orders.push(jsonFormatted);
  }

  async function sendForm() {
    const res = await fetch("http://localhost:8080/submit", {
      method: "POST",
      body: JSON.stringify(orderObj),
    });
    const resData = await res.json();
    return resData;
  }
  return sendForm()
    .then((arr) => arr.map((str) => {
      var p = document.createElement('p')
      p.textContent = str;
      p.style.color = "darkorchid";
      replyDiv.appendChild(p);
    }))
    .catch((err) => (replyDiv.innerHTML = err));
});
```
## .6 The main program
In this section we bring everything together to run our program. First we'll need a server to run `restService` we created previously. Create `Main.scala` in the following path, `src/main/scala/Main.scala` and add the following code.

```scala
import cats.effect.*
import fs2.Stream
import org.http4s.ember.server.EmberServerBuilder
import com.comcast.ip4s.*
import com.xonal.routes.MyRoutes.restService

object Main extends IOApp {
  def httpServerStream = Stream.eval(
    EmberServerBuilder
      .default[IO]
      .withHost(host"0.0.0.0")
      .withPort(port"8080")
      .withHttpApp(restService.orNotFound)
      .build
      .use(_ => IO.never)
  )
}
```
We use `EmberServerBuilder` to create our server with port number 8080 and build it with our `restService`. 

```scala
import com.xonal.service.Server.grpcServer

object Main extends IOApp {
  ...
  val grpcServerStream = Stream.eval(grpcServer)

  def run(args: List[String]): IO[ExitCode] = grpcServerStream
    .concurrently(httpServerStream)
    .compile
    .toList
    .as(ExitCode.Success)
}
```
We wrap both `httpServerStream` and `grpcServerStream` in an fs2 `Stream` so that we can run them `concurrently` in the last line.

Now Let's test our application.
When we run our server and navigate to `localhost:8080/index.html`, we should be greeted with the following page.

[image]()
Once we fill out the form and submit, we should see a response similar to the following.

[image]()

## 8. Managing currency with Squants.
Through out the article we've been representing money as `BigDecimal`, we could do better by using the Squants library to manage currency values, specifically the `Money` type. 
Therefore the question arises, if case classes are generated by ScalaPb, how can we make it so that scalapb generates Squant's `Money` type instead of a `Double` for `amount` and `total`? ScalaPb provides a mechanism for customising generated types convinient for such scenarios. 

We need to add the following two libraries to our `protobuf` project inside `build.sbt`.

```diff
...
lazy val protobuf =
  project
    .in(file("protobuf"))
    .settings(
      name := "protobuf",
      scalaVersion := scala3Version,
+     libraryDependencies += "com.thesamet.scalapb" %% "scalapb-runtime" % scalapb.compiler.Version.scalapbVersion % "protobuf",
+     libraryDependencies += "org.typelevel" %% "squants" % squantsVersion
    )
    .enablePlugins(Fs2Grpc)
...
```
Once we compile our project, we'll notice an extra file scalapb.proto in the following path `protobuf/target/protobuf_external/scalapb/scalapb.proto` which contains the necessary methods to make our type conversion.
Still in orders.proto lets import this new proto file into scope. 

```proto
syntax = "proto3";

package com.xonal.protos;

import "scalapb/scalapb.proto";
```

Now we can make changes to the `amount` for `Item` and `OrderReply`.

```diff
...
message Item{
  string name =1;
  int32 qty = 2;
- double amount = 3;
+ double amount = 3 [(scalapb.field).type = "squants.market.Money"];
}
...
message OrderReply {
  int32 orderid = 1;
  repeated Item items = 2;
- double total = 3;
+ double total = 3 [(scalapb.field).type = "squants.market.Money"];
}
```
Above, we set `(scalapb.field).type` to `squants.market.Money` which is the custom type we need for `amount` and `total`.

A few more extra steps are still required, let's create a `Customtype.scala` file in the following path `protobuf/src/main/protobuf/Customtype.scala` and add the following code.

```scala
package com.xonal.protos

import squants.market.{USD, Money}
import scalapb.TypeMapper

given typeMapper: TypeMapper[Double, Money] =
  TypeMapper[Double, Money](s => USD(s))(_.amount.toDouble)
```
Scalapb provides a TypeMapper object whose apply method takes two arguments, a function from the base type to a custom type i.e Double to Money, and a function from the custom type back to the base type i.e Money to Double. We provide typeMapper as a `given` so that when in scope, the generated scalapb case classes will be able to convert the `Double` to our expected `Money` type.

In order to bring this `given` into scope when the case classes are generated, we'll need to add this import as a File-level option inside our orders.proto file.

```diff
...
import "scalapb/scalapb.proto";

+ option (scalapb.options) = {
+  import: "com.xonal.protos.given"
+ };
...
```
Now that everything is set, let's compile our project and take a look at the cases classes generated by scalapb. We'll notice at the top of each of them is our import.

```scala
package com.xonal.protos.orders
import com.xonal.protos.given
...
```
And Item and OrderReply now have amount and total for Item and OrderReply respectively are of type `Money`.

```scala
final case class Item(
    name: _root_.scala.Predef.String = "",
    qty: _root_.scala.Int = 0,
    amount: squants.market.Money = com.xonal.protos.orders.Item._typemapper_amount.toCustom(0.0),
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) 
```
Make the following change to `OrderClient.scala`.

```diff
  def processorFn(orders: Stream[IO, OrderRequest]): IO[List[String]] = {
    def processor(orderStub: OrderFs2Grpc[IO, Metadata]): IO[List[String]] = {
      for {
        response <- orderStub.sendOrderStream(orders, new Metadata())
        str <- Stream.eval(
-          IO(s"Processed orderid: ${response.orderid} for items ${response.names
-              .mkString(",")} totaling to USD ${response.total}") 
+         IO(s"Processed orderid: ${response.orderid} for items: ${formatItemsToStr(response.items)
+             .mkString(" and ")}, totaling to ${response.total.toString}"
          )
        )
      } yield str
    }.compile.toList
    ...
  }
```
Here we use squants `toString` method which formats our values as follows: `xxx USD`.

Lastly, let's edit `AppRoutes.scala` as well.

```diff
...
  given itemDecoder: Decoder[Item] = Decoder.instance { h =>
    for
      name <- h.get[String]("name")
      qty <- h.get[Int]("quantity")
      amount <- h.get[BigDecimal]("amount")
    yield Item.of(
      name,
      qty,
-     amount
+     USD(amount)
    )
  }
...
```
Here we add `USD(amount)` of type Money to our itemDecoder.

Now we can run our application, we should see a similar result.

[image]()

## 9. Conclusion
In this article, we've looked at how to create, a grpc service in scala using fs2-grpc, this includes server and client implementation and how they communicate with each other. grpc is particular popular for communication between microservices and uses http/2 which provides better performance and reduced latency. 
Scalapb has alot more to offer than what was discussed in this article such as more customizations, transformations, extra sbt settings as well as some extra guides on usage with other scala libraries, I encourage you to dig into the documentation for more indepth knowledge on grpc in scala. 
The coplete code for this article can be found over on my GitHub account.